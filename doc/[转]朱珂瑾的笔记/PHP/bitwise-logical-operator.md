## PHP中关于短路符 &&，|| 以及位运算符的研究 ##
### Q1: 首先来看个问题 ###

	$a = 5;$b = 7;
	if ($a = 6 || $b = 7)
	{
		$a++;$b++;
	}
	echo $a . " " . $b;

上述结果输出结果是什么呢？有些人不细心，以为 `if` 句子里面是 `==`，就认为输出结果是 6 8 ，在仔细一看，括号里面是赋值，这样的话，输出结果是 7 8 ？

其实输出结果是：

>1 8

为什么输出1 8 呢？

。 

在if判断句中的第一个变量都会变成boolean，如果它的值不是0（false)任何其他的值都会被1取代， 而第一个变量的值是1(真)他就不会去判断第二个变量，直接跳过（返回真），那为什么 $a++ 没有执行呢？

因为 $a 在这里是 bool类型，不执行 ++ 操作 ， 所以如果把 $a++ 换成 $a = $a + 1; 的 话，这里就把 bool 类型的 $a 转化为 int 类型来进行处理。

因为 php 弱语言变量不强制类型的特性，这个问题就凸显了。

回到刚刚的问题，这里被运算符 || 短路了，在此运算符下，逻辑或认为有一个为真时，就结束运算，所以执行顺序是：

>$a = 5; -> $a === true; true++ ; echo $a; 

结果就是 1。

而 $b 所执行的操作就简单了:

>$b = 7;
>
>if 条件中不执行运算 （短路）。

>$b++;

输出结果为 8 。

**EX1:**

	$a==1 || $c = 100; 

逻辑或的运算结果是运算符（||）的两边只要有一个为真，结果就返回“真”后就不再执行其它表达式，所以在这个语句里已经判断到$a的返回值是“真”，就不再执行给$c赋值，这样就形成了一个短路现象，所以后面的输出语句不输出内容。

    $a==2 && $c=100;
逻辑与的运算符（&&），逻辑与的运算方式是运算符的两边表达式都为“真”才会继续执行其他语句而直接返回一个“假”值，所以这条语句也将不执行$c的赋值。

**EX**：
**短路的一个用法，判断读取文件是否存在：**

     @fopen("xxx.txt") or die("文件不存在");

  die命令是输出文本后，die后面的脚本都不会运行了，程序终止了。

----------


### Q2： 再来看一个问题###

	$a = 5;$b = 7;
	if ($a = 6 | $b = 7)
	{
		$a++;$b++;
	}
	echo $a . " " . $b;

注意不一样啊..里面是 | 不是 || 了

*提示一点这里不会短路啊..这里的 | （按位或运算符）没有短路特性*

这里没有怎么接触 运算符的 PHPER 就迷糊了


>按位运算符：按位与（&）和按位或(|),这两个运算符不存在短路特性，虽然它们的运算方式和逻辑与及逻辑或的运算方式相似，但他们没有存在短路现象，因为按位与它是参加运算的表达式的同位都为1时才返回1否则返回0，按位或是同位运算不相同时返回1否则返回0。

所以 Q2 执行的操作就是：



1. 十进制的 6 转化为 二进制 为 110
2. 十进制的 7 转化为 二进制 为 111
3. 执行 | 操作 ， 两边同步为 111
4. 转化为 十进制 为 7
5. 执行 ++ 操作
6. 输出结果 8 8


**底层操作博大精深...由浅入深慢慢研究..路漫漫其修远兮，吾将上下而求索。**